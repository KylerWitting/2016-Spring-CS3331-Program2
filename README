The README is used to answer questions posed by the professor. 
The Questions and programming assignment can be found in the PDF.

To Run
	make
	./main < testFile
		You may change the contents of testFile
		Stick to the format laid out in the PDF

testScript.sh is used to test the program 1000 times

// ----------------------------------------------------------- 
// NAME : Kyler Witting                      User ID: kmwittin 
// PROGRAM ASSIGNMENT 2
// FILE NAME : README
// PROGRAM PURPOSE :
//      The Makefile that answers the questions from the assignment
// -----------------------------------------------------------

1) The logic of your program 

2) Why does your program work?  

3) Explain the allocation and use of each shared memory segment.  

4) Are there potential race conditions (i.e., processes use and update a shared
data item concurrently) in your program and in the program specification?  

5) How do you construct an argument list that is passed from program main to
program qsort?  

6) How do you construct an argument list that is passed from program main to
program merge?


1) The logic of my program is pretty basic. I create an array out of shared
memory for each of the arrays that I will need. The arrays that I need are a
Qsort Array, an x and y array for the binary merge, and the output array for the
binary merge. With those arrays, I then use scanf to first find out how many
ints are in the array and then find that number of ints the array using a loop.
I store this information in shared memory. My main.c program has a printArray
method that keeps the line usage under 80 and prints out all the arrays that
were collected from stdin. Then I go into 2 forks that use execvp to call
qsort.c and merge.c. After that the main method waits for those child processes
to complete, and prints out the merged array and the sorted array using
printArray. It then goes through and detaches and removes all shared memory that
was used for this program and then returns. In qsort the program uses ftok to
get the key for the proper shared memory to get the array to sort. It then goes
through the quicksort algorithm. Instead of doing a recursive call that involves
passing the array, execvp is called to start qsort.c over again. The original
parent then waits for its children to finish before exiting the code. In merge.c
it uses ftok to get the keys for the x, y, and output array shared memory. After
getting the shared memory it goes through m+n to get all of the x elements and y
elements into the output array in the proper order. Each of the elements being
sorted is its own child because none of them overlap while being merged. They
all can be done individually and concurrently. The parent process waits for all
the children to exit before exiting itself. 

2) My program works because of shared memory and execvp calls. The shared memory
allows all the different programs to use the same set of data without passing it
around. It stays consistent and has its designated space. The qsort and merge
are able to be their own programs because of execvp while still sharing data
with main.c. My program is able to work much faster because of the concurrent
processes that occur in the merge and quicksort that wouldn't be possible
without fork. It would be impossible to do this assignment as laid out without
the ability to fork, use those forks for execvp, and then use shared memory in
the new programs that are running. 

3)  qKey is the first to read from stdin. It gets the size of its array from the
first int read. Using that size, it allocates memory the size of that many ints
for the array I will be using. Then it reads the data from stdin, into the space
it just created. IPC_CREAT to ensure failure if the segment already exists.
IPC_EXCL used with IPC_CREAT to ensure failure if the segment already exists.
mode_flags specify the permissions granted to the owner, group, and world. the
key is generated by ftok for this shared memory segment. Then the shared memory
is attached with shmat to the qArr, which is the array for qsort. All the other
shared memory segment allocation ses the same mode_flags (666), IP_CREAT, and
IPC_EXCL. They all use ftok to generate a key for them. They all get their sizes
from stdin and it is read in their order. The only different one is output
array, which uses m and n (the size of x and y array) to create an output array
for the binary merge. In qsort and merge the program just need to find the right
key using ftok, and then use smget with only the mode_flags and no IPC_CREAT or
IPC_EXCL to access it. Then attach it to the array specified. We then have a
shared memory array that is fully functional as an array in both programs. The
main.c method is responsible for closing out the shared memory so merge and
qsort don't need to worry about detaching or removing the shared memory. The
same process is used for the merge.c memory allocation to the arrays to be used.
It is basically a copy and paste of the original allocations, just without the
exclusive create flags. 

4) There are no race conditions in this program. While 2 or more processes
access the same resource at the same time, the outcome of the execution does not
depend on the particular order of which access takes place. With the binary
merge, there are m+n processes accessing the same output array because none of
the data entry or changes are overlapping or interfering with each other. The
quicksort can use "recursive", concurrent processes because quicksort splits up
the parts of the unsorted array and each concurrent part can work on their own
individual piece. The print statements of the final arrays could have been a
race condition but I put it behind the wait statements of the main.c program so
they had to wait until their child process that was doing the work was done with
the work. qsort and merge run on completely different data so there wouldn't be
any overlap there. Overall I believe there was a chance of one race condition,
but only if you were sloppy with how you printed your results. 

5) I used an argv char array of size 5, with 4 char strings to construct my
execvp and pass my arguments to the program I was calling. The first one I used
was prog, which stored what program I was calling, in this case it was
"./qsort". The "./" is necessary to run the file. I then assigned it to argv, in
spot 0, as is with a normal command line argument. I also put it first in the
execvp statement for the first argument. Next I used sprintf to turn my ints
into chars and put them into a temp char array. After putting each of them into
a temp placement, I passed it to argv. As I said, I put the prog name as the
argument zero, then I put k (the size of the array), as the first argument, the
initial left argument (which will always be 0) as the second argument, the
initial right argument (which is k-1), and then and EOF ( '\0' ) character. This
filled up the size 5 argv and then I passed argv to the execvp. So the final
execvp ended up as a very pretty "execvp( prog, argv2 );.

6) I used an argv char array of size 5, with 4 char strings to construct my
execvp and pass my arguments to the program I was calling. The first one I used
was prog, which stored what program I was calling, in this case it was
"./merge". The "./" is necessary to run the file. I then assigned it to argv, in
spot 0, as is with a normal command line argument. I also put it first in the
execvp statement for the first argument. Next I used sprintf to turn my ints
into chars and put them into a temp char array. After putting each of them into
a temp placement, I passed it to argv. As I said, I put the prog name as the
argument zero, then I put m (the size of the x array), as the first argument,
then I put n (the size of the y array) as the second argument, then the m+n
(size of the output array) as the third argument, and then and EOF ( '\0' )
character. This filled up the size 5 argv and then I passed argv to the execvp.
So the final execvp ended up as a very pretty "execvp( prog, argv2 );.

Personal Notes for help with the program

How to set indentation to 80 in vim 

:set textwidth=80 gg gqG


How to check leftover shared memory 

ipcs -m


How to delete leftover shared memory 

ipcrm shm <shmid>


